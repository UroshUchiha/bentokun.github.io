<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Animation Example</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>

<table border="0" width="100%" height="8" bgcolor="#eeeeee">
<tr> <td width="100%" height="1"><b><font size="2" color="#000000" face="Arial, Helvetica, sans-serif"><strong><a name=Top></a>
S60 5th Edition SDK </strong></font></b><br><i>Example Applications Guide</i></td></tr> </table>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>Animation Example</h1>
<p>
<a class="el" href="index.html#Intro_sec">1. About this Example</a> <br>
<a class="el" href="index.html#Arch_sec">3. Architecture</a> <br>
<a class="el" href="index.html#UI_sec">2. User interface</a> <br>
<a class="el" href="index.html#Design_sec">4. Design and Implementation</a><p>
<hr>
<h2><a class="anchor" name="Intro_sec">
1. About this Example</a></h2>
This tutorial explains the Animation application example, which is a simple, but complete, application demonstrating the use of the animation client/server architecture. The structure of the tutorial is based on the architecture of the application, which is shown in the UML component diagram below.<p>
<div align="center">
<img src="component.jpg" alt="component.jpg">
</div>
<p>
The tutorial starts by listing the pre-requisites the user should know before starting this example, and describes how to build and run the example. The documentation goes on to discuss how to implement an animation client/server, which is split into the following sections:<p>
<ul>
<li>The application GUI.</li><li>The animation client.</li><li>The animation server.</li></ul>
<p>
The example describes the basic principles of animation. It goes on to detail the design and implementation of the GUI and the animation client. Two different possible animation server implementations are described, one being more complicated, but more flexible, than the other.<p>
In the example application a small square moves continuously across the screen at a constant speed. Whenever it reaches the edge of the window, it bounces off in another direction.<p>
The Options menu presents the user with two options, as follows:<p>
<ul>
<li>Select <b>Reset</b> to return the square back to the top left corner of the display.</li><li>Select <b>Exit</b> at any time, to exit the application.</li></ul>
<p>
<hr>
<h3><a class="anchor" name="Sub11">
1.1 Prerequisites</a></h3>
This example exists as a complete application, and has the standard Symbian OS application architecture employing the Application, Document, UI, and View classes. The example makes use of several other Symbian OS concepts which the reader should be aware of before attempting to understand this example. These are:<p>
<ul>
<li>Client/server architecture.</li><li>Familiarity with the Window Server.</li><li>How to draw to a graphics context.</li></ul>
<p>
<hr>
<h2><a class="anchor" name="UI_sec">
2. User interface</a></h2>
When the application starts up, the following screen appears.<p>
<div align="center">
<img src="animation1.jpg" alt="animation1.jpg">
</div>
<p>
The small square moves continuously across the screen at a constant speed. Whenever it reaches the edge of the window, it bounces off in another direction.<p>
The <b>Options</b> menu presents the user with two options, as follows:<p>
<div align="center">
<img src="animation2.jpg" alt="animation2.jpg">
</div>
<p>
<ul>
<li>Select <b>Reset</b> to return the square back to the top left corner of the display.</li><li>Select <b>Exit</b> at any time, to exit the application.</li></ul>
<h2><a class="anchor" name="Arch_sec">
3. Architecture</a></h2>
The application is split into a client and a server, with the server doing the work of creating, controlling and deleting animated images directly, in the same high priority process as the Window Server. The client simply acts as a way for objects which are not in the same address space and thread as the Window Server to create and control images via the server. Redrawing images can be controlled by the Window Server, but this only allows a limited choice of redraw rates. Using a timer active object provides a wider choice of redraw rates.<h2><a class="anchor" name="Design_sec">
4. Design and Implementation</a></h2>
This section starts by giving an overview of the process required to animate an image. It then details the design and implementation of each of the following three components required to animate an image: the application GUI, the animation client, and the animation server.<h3><a class="anchor" name="Sub41">
4.1 The animation process</a></h3>
The image of the bouncing square is made to appear to move by repeatedly being drawn, erased and redrawn at regularly spaced positions on the screen, at regular time intervals. The frequency at which redraws are done is called the redraw rate. Redraws could be invoked under the direct control of application code, in the form of an active object regulated by a timer. However, because this would run on the client-side of the Window Server, it would suffer from the (relatively) lower priority of the client thread. Also, active objects are not pre-emptively scheduled. This means that a window update might be delayed or blocked altogether by another, already running, client-side active object. This would result in a varying redraw rate, and make the animation spasmodic, or stop it completely for a time.<p>
To achieve smoother animation, the drawing process can be controlled by the Window Server itself, in conjunction with some special application objects called the Animation Server. The Animation Server runs in the same thread as the Window Server. It draws, erases and redraws individual still images, one for each step of the animation, at intervals determined by the Window Server. This is illustrated in the UML sequence diagram below.<p>
<div align="center">
<img src="general_seq1.jpg" alt="general_seq1.jpg">
</div>
<p>
This is the first animation scenario, an animation server with restricted redraw rate. The Window Server calls the Animate function on the Animation Server at regular intervals. The Animate function can be programmed to erase the existing image and draw the next one in the animation sequence. The redraw rate is set by a call to the SetSync function on the Window Server, just after the Animation Server is created.<p>
However, the Window Server only allows a limited choice of redraw rates. The maximum rate is just two Animate calls per second. If a faster or non-standard redraw rate is required, a more refined mechanism must be used. One such refinement is illustrated by the UML sequence diagram below.<p>
<div align="center">
<img src="general_seq2.jpg" alt="general_seq2.jpg">
</div>
<p>
This is the second animation scenario, an animation server with less restricted redraw rate. Here the Animation Server has a built-in timer, which periodically invokes a function in the Animation Server which calls the Animate function on the Window Server. This, in turn, calls the Animate function on the Animation Server, which erases the existing image and draws the next one in the animation sequence. The process repeats at the rate determined by the Animation Server's timer period. This is the animation mechanism used in this example application.<h3><a class="anchor" name="Sub42">
4.2 The GUI package implementation</a></h3>
This section describes a typical use case scenario for the Animation application. The scenario is as follows:<p>
<ul>
<li>A GUI is Constructed. This, in turn, creates an animation client DLL object and image commander object. These objects create an animation server DLL object, which starts the square bouncing around the screen.</li><li>The user issues a Reset command, and the square is set back to the top left corner.</li><li>The user closes the application, and all the animation client and server objects are closed and destroyed.</li></ul>
<h3><a class="anchor" name="Sub421">
4.2.1 Construction</a></h3>
GUI Construction is illustrated in the sequence diagram below.<p>
<div align="center">
<img src="gui_seq1.jpg" alt="gui_seq1.jpg">
</div>
<p>
<ol type=1>
<li>The framework creates the GUI, which results in a call to the class Constructor.</li><li>Construction of the GUI causes the <a class="el" href="class_r_client_dll.html">RClientDll</a> object to be Constructed.</li><li>Construction of the GUI causes the <a class="el" href="class_r_image_commander.html">RImageCommander</a> object to be Constructed. Both <a class="el" href="class_r_client_dll.html">RClientDll</a> and <a class="el" href="class_r_image_commander.html">RImageCommander</a> classes are R-Type classes, which means they need special consideration when being Constructed and deleted. More information on how to Construct/destroy R-Type class objects is included in section 4.5 and section 4.6.</li><li>The framework calls the GUI ConstructL function to complete Construction.</li><li>SetUpClientDLL is called.</li><li>This, in turn, completes the Construction of the <a class="el" href="class_r_client_dll.html">RClientDll</a> object. Load is called on the <a class="el" href="class_r_client_dll.html">RClientDll</a> object and passed the name of the animation server to be loaded.</li><li>SetupImageCommander is called.</li><li>Calling SetupImageCommanderL results in a call to ImageConstruct upon the <a class="el" href="class_r_image_commander.html">RImageCommander</a> object, and completes Construction of the server-side image that will be animated.</li></ol>
<h3><a class="anchor" name="Sub422">
4.2.2 Sending a command</a></h3>
The next diagram illustrates the events that occur when the user selects Reset from the Options menu.<p>
<div align="center">
<img src="gui_seq2.jpg" alt="gui_seq2.jpg">
</div>
<p>
<ol type=1>
<li>The user interacts with the application, causing the HandleCommandL function to be called.</li><li>If <b>Reset</b> has been selected, the GUI informs the client by calling the ImageCommand function.</li></ol>
<h3><a class="anchor" name="Sub423">
4.2.3 Destruction</a></h3>
The final sequence diagram illustrates what occurs when the GUI objects are destroyed.<p>
<div align="center">
<img src="gui_seq3.jpg" alt="gui_seq3.jpg">
</div>
<p>
<ol type=1>
<li>The user closes the application.</li><li>The GUI destructor calls the Close function of the <a class="el" href="class_r_client_dll.html">RClientDll</a> object.</li><li>The GUI destructor calls the Close function of the <a class="el" href="class_r_image_commander.html">RImageCommander</a> object.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> object is destroyed.</li><li>The <a class="el" href="class_r_client_dll.html">RClientDll</a> object is destroyed.</li></ol>
<h3><a class="anchor" name="Sub43">
4.3 The animation client</a></h3>
The previous section has shown how the GUI manipulates the <a class="el" href="class_r_client_dll.html">RClientDll</a> and <a class="el" href="class_r_image_commander.html">RImageCommander</a> objects. This section describes how these classes are implemented in terms of the animation server. <a class="el" href="class_r_client_dll.html">RClientDll</a> and <a class="el" href="class_r_image_commander.html">RImageCommander</a> provide client-side interfaces to the animation server, which allow the user-interface code to (indirectly) control images on the server-side. The animation server itself is described later.<p>
An instance of <a class="el" href="class_r_client_dll.html">RClientDll</a> is an object used to load and destroy the animation server. An instance of <a class="el" href="class_r_image_commander.html">RImageCommander</a> is an object which can be used to create, via the animation server, a new animated image. It can then be used to dynamically control this image's behaviour. Typically, each different kind of animated image requires an instance of <a class="el" href="class_r_image_commander.html">RImageCommander</a> to create, manipulate and destroy it. <a class="el" href="class_r_image_commander.html">RImageCommander</a> instances must be created after the <a class="el" href="class_r_client_dll.html">RClientDll</a> object.<h3><a class="anchor" name="Sub431">
4.3.1 The animation client class hierarchy</a></h3>
The <a class="el" href="class_r_client_dll.html">RClientDll</a> and <a class="el" href="class_r_image_commander.html">RImageCommander</a> classes derive much of their functionality from the Symbian OS classes RAnimDll and RAnim respectively. The UML class diagram below shows the relationships between the animation client package classes and the Symbian OS classes.<p>
<div align="center">
<img src="clientclass.jpg" alt="clientclass.jpg">
</div>
<p>
The <a class="el" href="class_r_client_dll.html">RClientDll</a> class is derived from the Symbian OS RAnimDll base class. Every instance of <a class="el" href="class_r_client_dll.html">RClientDll</a> is linked to a Window Server session, that is an instance of class RWsSession. This is the session that the animation server will interact with when the server is loaded.<p>
The <a class="el" href="class_r_image_commander.html">RImageCommander</a> class is derived from the Symbian OS RAnim class. Every instance of <a class="el" href="class_r_image_commander.html">RImageCommander</a> is attached to an instance of a <a class="el" href="class_r_client_dll.html">RClientDll</a> class. The link is made when the <a class="el" href="class_r_image_commander.html">RImageCommander</a> object is created.<p>
<a class="el" href="class_r_image_commander.html">RImageCommander</a> derives three important functions from RAnim:<p>
<ul>
<li>Construct</li><li>Command</li><li>Close</li></ul>
<p>
The Construct function causes a new animation image to be created by the animation server.<p>
The Command function passes a 'command', in the form of an integer operation code, to the animation server. The animation server can be programmed to interpret this in whatever way is appropriate. Typically, a command will relate to dynamically controlling the animated image's behaviour.<p>
The Command function does not return a value, and is a buffered operation. The fact that it does not return a value means that it should only be used for actions that cannot leave or fail, because should the action fail, there is no way for the server to signal this to the client. The fact that the action is buffered means that completion of the action is asynchronous to the request. This means a latency will be introduced between the request and an action being performed.<p>
There is another RAnim function, CommandReply, which is similar to Command but it does return a value, and is unbuffered. As this function returns a value, it may be used for actions that can fail. Through the return value, the client-side can be informed of any failures, and respond accordingly. The fact that the action is unbuffered means that it will generally not return until the requested action has been completed. For this reason, it is recommended that any actions performed are relatively short.<p>
Note that the Command and CommandReply functions of the RAnim class are protected, therefore anything deriving from this will need to publish a public function to make these functions publicly accessible.<p>
The Close function requests the animation server free all the resources belonging to an object.<h3><a class="anchor" name="Sub432">
4.3.2 Using the animation client</a></h3>
This section describes a simple use case scenario for the Animation Client. It demonstrates the Animation Client objects being:<p>
<ul>
<li>Constructed</li><li>Used to load and start the animation server, which starts the bouncing square animation</li><li>Resetting the animation, so that the bouncing square jumps back to the top-left corner and moves off again</li><li>Closed</li></ul>
<h3><a class="anchor" name="Sub4321">
4.3.2.1 Construction</a></h3>
Construction of an animation client is shown in the sequence diagram below.<p>
<div align="center">
<img src="client_seq1.jpg" alt="client_seq1.jpg">
</div>
<p>
<ol type=1>
<li>An animation client DLL object is created. A Window Server session is passed to it, so that the DLL is able to attach an animation server to this Window Server session.</li><li>An instance of <a class="el" href="class_r_image_commander.html">RImageCommander</a> is Constructed. The Constructor is passed a reference to an animation client DLL. In this example this is the <a class="el" href="class_r_client_dll.html">RClientDll</a> object created by (1).</li><li>To load a server-side animation DLL, Load is called upon the <a class="el" href="class_r_client_dll.html">RClientDll</a> object. This is passed the filename of the animation server DLL to load. Note that it is not necessary to put the DLL file extension on this filename. The location of the animation server DLL file may be different in the emulator and target builds.</li><li>A Window Server is loaded.</li><li>The Window Server creates an animation DLL object.</li><li>The client-side <a class="el" href="class_r_image_commander.html">RImageCommander</a> object is used to create an instance of the server-side <a class="el" href="class_c_image.html">CImage</a> class. This is achieved by calling ImageConstruct.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> calls RAnim::Construct.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> constructs the image.</li><li>This causes the Window Server to call <a class="el" href="class_c_server_dll.html#69a6ea9136b5c480c4c54ce190c3ffdc">CServerDll::CreateInstanceL</a>, and passes it an argument indicating what type of image should be created. A single instance of <a class="el" href="class_c_server_dll.html">CServerDll</a> may be used to create multiple animation images.</li><li>An instance of <a class="el" href="class_c_image.html">CImage</a> is then Constructed.</li></ol>
<h3><a class="anchor" name="Sub4322">
4.3.2.2 Sending a command</a></h3>
Having successfully Constructed a server-side image, the user may wish to send commands to it. In this example, the Reset command is sent to restart animation at the top left of the display. This is achieved using the ImageCommand function, and is shown in the sequence diagram below.<p>
<div align="center">
<img src="client_seq2.jpg" alt="client_seq2.jpg">
</div>
<p>
<ol type=1>
<li>The user selects Reset from the Options menu.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> calls RAnim::Command.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> then sends a message to the Window Server.</li><li>Sometime later the Window Server calls the Command function of the server-side <a class="el" href="class_c_image.html">CImage</a> class, and passes an argument that indicates the type of command required. For this example this is set to KAnimationReset, which resets the animation.</li></ol>
<h3><a class="anchor" name="Sub4323">
4.3.2.3 Destruction</a></h3>
The final stage is when the image object needs to be destroyed and the animation server closed down. This is done by calling Close operations on the <a class="el" href="class_r_image_commander.html">RImageCommander</a> and <a class="el" href="class_r_client_dll.html">RClientDll</a> objects. The correct sequence is shown in the diagram below.<p>
<div align="center">
<img src="client_seq3.jpg" alt="client_seq3.jpg">
</div>
<p>
<ol type=1>
<li>RImageCommander::Close is called.</li><li>The <a class="el" href="class_r_image_commander.html">RImageCommander</a> instructs the Window Server to destroy the relevant server-side <a class="el" href="class_c_image.html">CImage</a> object.</li><li>The Window Server destroys the relevant server-side <a class="el" href="class_c_image.html">CImage</a> object.</li><li>Once all the server-side images has been destroyed, the server-side DLL can be unloaded. This is achieved by calling RClientDll::Close.</li><li>The <a class="el" href="class_r_client_dll.html">RClientDll</a> instructs the Window Server to unload and destroy the server-side animation DLL.</li><li>The Window Server unloads and destroys the server-side animation DLL.</li></ol>
<h3><a class="anchor" name="Sub44">
4.4 The animation server</a></h3>
This section describes two possible implementations of the animation server. The difference between them is the mechanism used to determine when each individual image in the animation sequence is drawn. The two implementations use, respectively:<p>
<ul>
<li>The Window Server</li><li>A timer</li></ul>
<p>
The first implementation has the restriction that the image can't be redrawn at a rate greater than twice per second, the rate set by a Window Server limitation. The second implementation is more complicated than the first, but has the advantage that the upper limit to the redraw rate is higher.<p>
Both implementations incorporate the two classes, <a class="el" href="class_c_server_dll.html">CServerDll</a> and <a class="el" href="class_c_image.html">CImage</a>. The second implementation has two extra timer classes, CTimeoutTimer and <a class="el" href="class_m_timeout_notify.html">MTimeoutNotify</a>.<h3><a class="anchor" name="Sub441">
4.4.1 The animation server class hierarchy</a></h3>
The classes necessary to create an animation server are summarised in the UML class diagram below.<p>
<div align="center">
<img src="server_class.jpg" alt="server_class.jpg">
</div>
<p>
An instance of <a class="el" href="class_c_image.html">CImage</a> corresponds to a specific animated image on the screen. In this example, it calculates the position for the bouncing square, and draws it.<p>
An instance of <a class="el" href="class_c_server_dll.html">CServerDll</a> is a 'factory' object, which creates a new instance of <a class="el" href="class_c_image.html">CImage</a>. The two classes have to present a specific interface to the Window Server, which they derive from two Symbian OS classes CAnimDll and CAnim. The CreateCAnimDllL function is used to create the <a class="el" href="class_c_server_dll.html">CServerDll</a> object.<h3><a class="anchor" name="Sub442">
4.4.2 Animation server with restricted redraw rate</a></h3>
There are four main tasks that have to be performed for the server-side animation to work. These are:<p>
<ul>
<li>Load and start the animation server.</li><li>Start the bouncing square animation.</li><li>Reset the running animation, so that the bouncing square jumps back to the top-left corner, and moves off again.</li><li>Close the animation and the animation server.</li></ul>
<p>
Loading and Constructing the animation server has already been discussed in The animation client section. This section focuses on what occurs once the animation server has been Constructed. The diagram below shows the events that occur from the point where the <a class="el" href="class_c_image.html">CImage</a> object is created, to when the first call to Animate is made.<p>
<div align="center">
<img src="server_sync.jpg" alt="server_sync.jpg">
</div>
<p>
<ol type=1>
<li>SetSync is called on the Window Server. This specifies the redraw rate of the image.</li><li>After a specified time, determined by the redraw rate, the Window Server calls the Animate function on the <a class="el" href="class_c_image.html">CImage</a> object. Animate calculates the position of the bouncing square.</li><li>It then calls the Invalidate function, which informs the Window Server that the display needs to be updated.</li><li>The Window Server calls Redraw on all the animated objects that have been invalidated (in this case, there is only the <a class="el" href="class_c_image.html">CImage</a> object).</li><li>The pen colour is set to white.</li><li>The Redraw function overwrites the last animation position with a white rectangle. This effectively erases the previous image.</li><li>The pen colour is set to black.</li><li>A rectangle is drawn at the new position calculated by (2).</li></ol>
<p>
Steps 2 - 8 are repeated at the Redraw rate. With the limitations of the Window Server, this occurs a maximum rate of twice a second.<h3><a class="anchor" name="Sub443">
4.4.3 Animation server with less restricted redraw rate</a></h3>
The second implementation, where there is a higher upper limit to the redraw rate, incorporates some extra member functions and variables in <a class="el" href="class_c_image.html">CImage</a>, and two extra classes, CTimeoutTimer and <a class="el" href="class_m_timeout_notify.html">MTimeoutNotify</a>. The UML class diagram below shows the relationships between the CAnimDll and <a class="el" href="class_c_image.html">CImage</a> classes and various Symbian OS classes, and the timer classes.<p>
<div align="center">
<img src="server_async.jpg" alt="server_async.jpg">
</div>
<p>
An instance of CTimeoutTimer is an active object, which can be programmed to timeout after a specific interval. When it does time out, it calls the TimedOut function on an 'observer' object. The timer observer must be registered with the timer when the timer is created. The object must also be an instance of a class derived from the mixin class <a class="el" href="class_m_timeout_notify.html">MTimeoutNotify</a>.<p>
Here, the registered observer is the <a class="el" href="class_c_image.html">CImage</a> object, and so the timer calls TimedOut on this. This, in turn calls Animate and puts a Redraw into effect. The process is illustrated in more detail in the UML sequence diagram below.<p>
<div align="center">
<img src="server_async_seq.jpg" alt="server_async_seq.jpg">
</div>
<p>
<ol type=1>
<li>The <a class="el" href="class_c_image.html">CImage</a> object calls SetSync on the Window Server, with an argument ESyncNone. ESyncNone specifies that the Window Server should not initiate Animate calls on <a class="el" href="class_c_image.html">CImage</a>.</li><li>The <a class="el" href="class_c_image.html">CImage</a> object creates the CTimeoutTimer object.</li><li>It then calls the After function on it, which instructs it to call TimedOut on <a class="el" href="class_c_image.html">CImage</a> after a set period of time has elapsed.</li><li>After the set period of time has elapsed, the timer calls TimedOut on <a class="el" href="class_c_image.html">CImage</a>.</li><li>The <a class="el" href="class_c_image.html">CImage</a> calls the After function, to schedule the next redraw period.</li><li><a class="el" href="class_c_image.html">CImage</a> calls the Window Server's Animate function.</li><li>This results in <a class="el" href="class_c_image.html#5921eff3105ddb0252785d6088a78426">CImage::Animate</a> being called. Note that it is not possible to call <a class="el" href="class_c_image.html#5921eff3105ddb0252785d6088a78426">CImage::Animate</a> directly, as the Window Server needs to perform some initialisation first.</li><li>Animate first calculates the position of the bouncing square. It then calls the animation Invalidate function, which informs the Window Server that the display needs to be updated.</li><li>The Window Server calls Redraw on all the animated objects that have been invalidated (in this case there is only the <a class="el" href="class_c_image.html">CImage</a> object).</li><li>The pen colour is set to white.</li><li>The Redraw function overwrites the last animation position with a white rectangle. This effectively erases the previous image.</li><li>The pen colour is set to black.</li><li>A rectangle is drawn at the new position, calculated by (2).</li></ol>
<p>
After the set period of time has elapsed, the timer calls TimedOut on <a class="el" href="class_c_image.html">CImage</a>. The whole redraw process is then repeated. By changing the timer period, it is possible to alter how often the square is redrawn. Care should be exercised, however, because if the timer period is too short then animation can become jerky as the image is moved. This is because there is not sufficient time to draw the new position before the square is moved again. Note that the timer resolutions for the emulator and target builds are different: 1/10 of a second for the emulator, and 1/64 of a second for the target. Also, the target is able to cope with a much lower timer period (i.e. more frequent redraws) than the emulator before it starts to have trouble drawing the image.<h3><a class="anchor" name="Sub45">
4.5 Animation client classes R-Type Construction</a></h3>
One slightly unusual feature of the Animation application is that the animation client DLL and image commander classes are both R-Type classes. This means that the objects these classes control are actually owned elsewhere, in this case by the Window Server. Because these classes are R-Types, their instances are Constructed automatically by their containing object's Constructor. However, the Constructors need to take certain parameters, in order to Construct correctly. The passing of these parameters to the Constructor is achieved by explicitly calling the R-Type class's Constructor in the owning class's Constructor list. An example of this is shown when the GUI application UI Constructs the animation client.<p>
The Constructor performs the following tasks:<p>
<ul>
<li>Call the base class Constructor for the UI.</li><li>Call the Constructor for the animation client DLL (RAnimDll derived) class, passing it a reference to a Window Server session.</li><li>Call the Constructor for the animation client image commander (RAnim derived) class, passing it a reference to the animation client DLL object Constructed in the previous step.</li></ul>
<p>
These objects need to be Constructed in this manner to avoid calling the default Constructors, which would not initialise the objects correctly. The order in which the two R Class objects are Constructed is very important, as Construction of the image commander takes the client DLL as a parameter. However, the order of Construction is defined by the order of the member variables within the class definition, not the Constructor initialisation list. Therefore, the class definition must declare these variables in the correct order, for the Construction to work correctly.<h3><a class="anchor" name="Sub46">
4.6 Animation client classes R-Type destruction</a></h3>
Because the Animation Client classes are R-Types, they are automatically destroyed by the class that owns them, and there is no need to destroy them explicitly in the destructor. It is necessary to free whatever resources they might be using, however. This is done by calling the Close function on each of the R-Type objects, as performed by the UI's destructor.<h3><a class="anchor" name="Sub47">
4.7 The MMP file</a></h3>
Each Symbian OS application has an associated MMP file. The MMP file defines such things as which source files are to be compiled, which libraries to be linked, and so on. To create an animation server DLL, it is necessary to specify the target type and UID in the MMP. These should be set to the values shown below.<p>
<div class="fragment"><pre class="fragment"> TARGETTYPE ani
 UID 0x10003b22
</pre></div> <hr>

<table x-use-null-cells
		style="x-cell-content-align: top;
				width: 100%;
				border-spacing: 0px;
				border-spacing: 0px;"
		cellspacing=0
		width=100%>
  <col style="width: 50%;">
  <col style="width: 50%;">

  <tr style="x-cell-content-align: top;"
	valign=top>
  <td style="width: 50%;
			padding-right: 10px;
			padding-left: 10px;
			border-right-style: None;
			border-left-style: None;
			border-top-style: None;
			border-bottom-style: None;"
	width=50%>
  <p style="font-family: Arial;"><small style="font-size: smaller;">© Nokia 2009</small></td>
  <td style="width: 50%;
			padding-right: 10px;
			padding-left: 10px;
			border-top-style: None;
			border-bottom-style: None;
			border-right-style: None;"
	width=50%>
  <p style="text-align: right; margin-right: -4px;"
	align=right><span style="font-weight: bold;"><a href="#Top"
													title="Back to top"><img
 src="top.gif"
	x-maintain-ratio=TRUE
	alt="Back to top"
	style="border: none;
			width: 18px;
			height: 15px;
			float: none;
			border-style: none;
			border-style: none;"
	width=18
	height=15
	border=0></a></span></td></tr>
 </table>
</body>
</html>

