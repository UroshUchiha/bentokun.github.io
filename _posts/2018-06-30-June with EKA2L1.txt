--- 
layout: default
comments: enable
---

Hi, I'm not lazy xD. Cut it off, just want to share with you what I have done in June with EKA2L1. I have a lot of free time in summer, as I
still a high school student and didn't really work part time anywhere, so I work part time in this, almost every night. So I have a lot of things 
to show you.

## 1. Console implementation
- This makes the example console app work. Basiclly, I speed things up, ignore Console IPC calls and overwrite with my own implementation. 
- Fortunately, it runs, but the pipeline right now is really messed up. It calls for rendering every 2048 ticks, after downcount (20 000 ticks) will
reschedule thread. I don't expect it to manually do rendering, but I do it for the sake of displaying the console text.
- As you see, it renders a console. The real console works by opening another DLL (image in Symbian calling), and calling ordinal X, which functions
implement by calling a Console Server
- Here is the image of it running my console test. 
- ![Console](https://media.discordapp.net/attachments/431430141319708692/455664435717996544/Symbian.png?width=255&height=473)

## 2. Appveyor CI
- I intergrated a CI to EKA2L1. As not many contributors right now, it allow users (mostly on Discord), download builds and test for me. And yeah,
I fix many dumb things from test by users :D, shoutout to them <3.
- The hardest thing when implementing this CI is, I uses Lazarus UI. I will talk about GUI later, but there's no Lazarus Pascal provided. And the NewPascal
supports only 32 bit. So I have to upload my own ver. However, the saddest thing is Lazarus will crash randomly (probally because of the memory on 
Appveyor).
- You can download artifacts from [here](https://ci.appveyor.com/project/bentokun/eka2l1-mjiuq).

## 3. The UI
- I don't have much experience in QT, and don't bother downloading 6GB just to make the GUI for now. When someone experiences with Qt work with the GUI,
I will switch to it. It has big advantages, considering I'm using C++ to write the core. 
- Here is the thin layer in Pascal. It's really easy to import :D, Pascal is actually useful sometimes.
- <script src="https://gist.github.com/bentokun/7d55361402977c987132d61fd60a5a92.js"></script>
- For now, I just make a thin DLL layer for it. I wrote a Pascal unit import those core functions from the DLL.
- As now, the GUI is pretty usable. You can install, run things asynchronously. Here is a picture of it:
- ![GUI Picture](https://media.discordapp.net/attachments/431430141319708692/455663094807658497/Symbian.JPG?width=645&height=474)

## 4. IPC Meachanics
- The most important things that I have done this month in EKA2L1 is implementing IPC server and client. Some parts are extremely similar to 3DS and 
Switch, so I just references some code from Citra (sorry). But mostly, I implement it myself. 3DS's IPC has more sane then Symbian's IPC, just some parts
are similar, like the property and storage buffer in Switch, or the IPC synchronous execution. 
- Let me explain these two mechanics.

- ### A. IPC
   * IPC (Inter-process communication), is the way two processes communicate with each other. A process give some specific request (call it client), through 
   IPC, that requests is transfer to another process for processing (server).
   * In Symbian, it allow user sends the function opcode with IPC args (TIpcArgs) through the *SendReceive / Send* functions. IPC arguments are either
   binary, text or integer (handle). The function opcode along with args are packed into a message, transfer to the correspond kernel server, which puts it
   in a waiting queue. When a process wants to get a message to dispatch and processing, it calls *Receive*. The message is taken from the waiting queue (accepted)
   , got accepted and transfer to the server process.
   
   


